# -*- coding: utf-8 -*-
"""
Created on Fri Jan 14 14:02:25 2022

@author: wisse
"""

# -*- coding: utf-8 -*-
"""
Spyder Editor

This is a temporary script file.
"""
import random as random
import numpy as np
import math as math
import matplotlib.pyplot as plt

#GreaterThan checks if a sequence of 'digits' Possibility1 is ordered after (1) before (0) or 
#Whether it is equal(2) to Possibility 2
def GreaterThan(Possibility1,Possibility2):
    if not len(Possibility1) == len(Possibility2):
        print('error')
        return 'error'
    for i in range(len(Possibility1)):
        if Possibility1[i] == Possibility2[i]:
            continue
        if Possibility1[i] > Possibility2[i]:
            return 1
        else: return 0
    return 2


Tries = 0
###
#Generate a list of all 24 proper rotations that are symmetries of the cube as 
#np arrays representing linear transformation matrices
###
def GenerateCubeRotations():
    Permutations3 = [[0,1,2],[0,2,1],[1,2,0],[1,0,2],[2,0,1],[2,1,0]]
    Mirrors = [[],[0,1],[0,2],[1,2]]
    CubeRotations = []
    for Permutation in Permutations3:
        for Mirror in Mirrors:
            CubeRotation = np.zeros((3,3))
            for i in range(3):
                if i in Mirror:
                    CubeRotation[i,Permutation[i]] = -1
                else:
                    CubeRotation[i,Permutation[i]] = 1
            CubeRotations.append(CubeRotation)
    return CubeRotations

def RotateShape(Shape, Rotation):
    if len(Shape) == 0:
        print('Catastrofic RotateShape Error')
        return []
    TotalSum = np.array([0,0,0])
    for Location in Shape:
        TotalSum += Location
    Average = TotalSum/len(Shape)
    MidPoint = np.rint(Average).astype(int)
    RotatedShape = [np.rint(np.matmul(Rotation,Location - MidPoint) + MidPoint).astype(int) for Location in Shape]
    return RotatedShape

###
#Generates the grid coordinates of a Shape, where the location of the Shape
#is determined by rotationlabel Shapeconfiguration[0] and translation
#Shapeconfiguration[1], with respect to a starting position of the shape. 
###
def GenerateShapeLocation(ShapeConfiguration,Shape, CubeRotations):
    Rotation = CubeRotations[ShapeConfiguration[1]]
    Translation = ShapeConfiguration[0]
    RotatedShape = [np.matmul(Rotation,Location) for Location in Shape]
    TranslatedShape = [np.rint(np.add(Translation,Location)).astype(int) for Location in RotatedShape]
    return TranslatedShape

###
#Checks whether all grid coordinates of a Shape are all contained in the 5x5x5
#grid. 
###
def GoodShapeLocation(ShapeLocation):
    for Location in ShapeLocation:
        if np.any(Location > 4.5):
            return 0 
        if np.any(Location < -0.5):
            return 0 
    return 1

###
#This function adds a shape to the cube. It also computes the 
#Energy difference generated by adding this shape
###
def AddShapeToCube(Cube,ShapeLocation):
    EnergyDifference = 0
    for Location in ShapeLocation:
        Value = Cube[tuple(Location)]
        if not Value == 0:
            EnergyDifference += 2*Value - 1
        Cube[tuple(Location)] = Value + 1
    return EnergyDifference

"""
This function checks whether Shapes in the cube overlap
"""
def CheckCubeConsistency(Cube, Locations):
    for Location in Locations:
        if not Cube[tuple(Location)] == 0 or Cube[tuple(Location)] == 1:
            return 0
    return 1
"""
This function removes a shape from the cube. It prints an error if 
there is no shape in this location. However, it would be better to check if
there is a shape at this location before doing any
"""
def RemoveShapeFromCube(Cube,ShapeLocation):
    EnergyDifference = 0
    for Location in ShapeLocation:
        Value = Cube[tuple(Location)]
        if Value == 0: print('error RemoveShape, Catastrophic')
        if not Value == 1:
            EnergyDifference += 3 - 2*Value
        Cube[tuple(Location)] = Cube[tuple(Location)] - 1
    return EnergyDifference


#Calculate the energy of a specific cube
def EnergyFunction(Cube):
    Energy = 0
    for index, value in np.ndenumerate(Cube):
        if not value == 0:
            Energy = Energy + (value - 1)**2
    return(Energy)
            
#This function tries all possible configurations for a block. If the
#Block fits, it tries a new block. If it finishes the puzzle, it returns 1, 
#If it does not finish the puzzle, a nnew configuration is tried out

#This function modifies the ShapeLocations and Cube
# by replacing it with a neighbour.
#It then reports the Energy Difference, and tells how it has changed the Cube 
#After applying this function, this allows the change to be reverted
#This function can calculate the energy difference faster than
#The energy function
def Neighbour(ShapeLocations,Cube,Rotations):
    #For now, we only allow translations
    ShapeRemovedIndex  = random.choice(range(len(ShapeLocations)))
    ShapeRemoved = ShapeLocations[ShapeRemovedIndex]
    #print(ShapeRemoved)
    EnergyDifference = 0
    DecisionParameter = random.random()
    if DecisionParameter > 0.5: #Translate
        NewShapeLocation = []
        Translation = np.array(random.choice(
            [[0,0,1],[1,0,0],[0,1,0],[0,0,-1],[-1,0,0],[0,-1,0]]))
        for Location in ShapeRemoved:
            NewShapeLocation.append(Translation + Location)
           
    else: #Rotate
        RandomRotation = random.choice(Rotations)
        NewShapeLocation = RotateShape(ShapeRemoved,RandomRotation)
    if GoodShapeLocation(NewShapeLocation):
        EnergyDifference += AddShapeToCube(Cube,NewShapeLocation)
        EnergyDifference += RemoveShapeFromCube(Cube,ShapeRemoved)
        return EnergyDifference,NewShapeLocation,ShapeRemoved, ShapeRemovedIndex
    return 0,[],[],0


def GenerateBaseShapes():
    ShapeL = [np.array([i,j,0]) for i in range(4) for j in range(2)]
    for j in range(2):
        ShapeL.append(np.array([3,j,1]))
    ShapeY = [np.array([i,j,0]) for i in range(4) for j in range(2)]
    for j in range(2):
        ShapeY.append(np.array([2,j,1]))
    return ShapeL,ShapeY

def GenerateCube(CubeSize):    
    Cube = np.zeros((CubeSize,CubeSize,CubeSize))
    Locations = [np.array([i,j,k]) for i in range(CubeSize) 
                     for j in range(CubeSize) for k in range(CubeSize)]
    return Cube,Locations



def GenerateAllowedShapeLocations(Shape, ShapeConfigurations, CubeRotations):
    PossibleShapeLocations = [GenerateShapeLocation(ShapeConfiguration, Shape, CubeRotations)
                       for ShapeConfiguration in ShapeConfigurations]
    ProperShapeLocations = [ShapeLocation for ShapeLocation in PossibleShapeLocations
                             if GoodShapeLocation(ShapeLocation)]
    ProperShapeConfigurations = [ShapeConfiguration
                       for ShapeConfiguration in ShapeConfigurations
                       if GoodShapeLocation(
                               GenerateShapeLocation(ShapeConfiguration, Shape, CubeRotations))]
    return ProperShapeLocations, ProperShapeConfigurations
    
    
def main():
    ShapeL,ShapeY = GenerateBaseShapes()
    Cube,Locations = GenerateCube(5)
    
    RotationLabels = [i for i in range(24)]
    ShapeConfigurations = [[Location,RotationLabel] for Location in Locations
                     for RotationLabel in RotationLabels]
    
    CubeRotations = GenerateCubeRotations()
    
    ShapeLLocations, ShapeLConfigurations = GenerateAllowedShapeLocations(ShapeL, ShapeConfigurations, CubeRotations)
    ShapeYLocations, ShapeYConfigurations = GenerateAllowedShapeLocations(ShapeY, ShapeConfigurations, CubeRotations)

    #In this code, we build two global objects. The ConfigurationTracker tracks
    #the configurations used to build blocks. The Cube tracks which locations
    #contain blocks. We try to add blocks until all blocks are contained in the
    #Cube. Then the functions and loops should end. 
    for i in range(10):
        Cube,Locations = GenerateCube(5)
        ShapeLocations = random.sample(ShapeLLocations,6) + random.sample(ShapeYLocations,5)
        for ShapeLocation in ShapeLocations:
            AddShapeToCube(Cube,ShapeLocation)
        Energies = []
        Energy = EnergyFunction(Cube)
        Energies.append(Energy)
        MinEnergy = Energy
        BestShapeLocations = ShapeLocations
        Tmax = 20
        T = Tmax
        DecayRate = 0.0001
        Tmin = 0.1
        Once = 1
        while T > Tmin:
            EnergyDifference,ShapeAdded,ShapeRemoved, ShapeIndex = Neighbour(ShapeLocations,Cube, CubeRotations)
            if ShapeAdded:
                if EnergyDifference > 0 and random.random() > math.exp(-EnergyDifference/T):
                    EnergyDifference += AddShapeToCube(Cube,ShapeRemoved)
                    EnergyDifference += RemoveShapeFromCube(Cube,ShapeAdded)
                else:
                    del ShapeLocations[ShapeIndex]
                    ShapeLocations.append(ShapeAdded)
                    Energy = Energy + EnergyDifference
                    Energies.append(Energy)
                    if MinEnergy > Energy:
                        BestShapeLocations = ShapeLocations
                        BestCube = Cube
                    MinEnergy = min(MinEnergy,Energy)
                T = T*(1-DecayRate)
                if Once and T < 1:
                    Once = 0
                    DecayRate = DecayRate/4
                if CheckCubeConsistency(Cube, Locations):
                    print('Cube Solved')
                    break
        print(BestCube, MinEnergy, BestShapeLocations)
        plt.plot(Energies)
        plt.ylabel('Energy')
        plt.show()         
if __name__ == "__main__":
    main()

              
              