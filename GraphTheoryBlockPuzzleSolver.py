# -*- coding: utf-8 -*-
"""
Created on Fri Jan 14 14:02:25 2022

@author: wisse
"""

# -*- coding: utf-8 -*-
"""
Spyder Editor

This is a temporary script file.
"""
import random as random
import numpy as np
import math as math
#import matplotlib.pyplot as plt
import pickle as pickle
import time as time
import os 
import copy as copy
dir_path = os.path.dirname(os.path.realpath(__file__))
#GreaterThan checks if a sequence of 'digits' Possibility1 is ordered after (1) before (0) or 
#Whether it is equal(2) to Possibility 2
def GreaterThan(Possibility1,Possibility2):
    if not len(Possibility1) == len(Possibility2):
        print('error')
        return 'error'
    for i in range(len(Possibility1)):
        if Possibility1[i] == Possibility2[i]:
            continue
        if Possibility1[i] > Possibility2[i]:
            return 1
        else: return 0
    return 2


Tries = 0
###
#Generate a list of all 24 proper rotations that are symmetries of the cube as 
#np arrays representing linear transformation matrices
###
def GenerateCubeRotations():
    Permutations3 = [[0,1,2],[0,2,1],[1,2,0],[1,0,2],[2,0,1],[2,1,0]]
    Mirrors = [[],[0,1],[0,2],[1,2]]
    CubeRotations = []
    for Permutation in Permutations3:
        for Mirror in Mirrors:
            CubeRotation = np.zeros((3,3))
            for i in range(3):
                if i in Mirror:
                    CubeRotation[i,Permutation[i]] = -1
                else:
                    CubeRotation[i,Permutation[i]] = 1
            CubeRotations.append(CubeRotation)
    return CubeRotations

def RotateShape(Shape, Rotation):
    if len(Shape) == 0:
        print('Catastrofic RotateShape Error')
        return []
    TotalSum = np.array([0,0,0])
    for Location in Shape:
        TotalSum += Location
    Average = TotalSum/len(Shape)
    MidPoint = np.rint(Average).astype(int)
    RotatedShape = [np.rint(np.matmul(Rotation,Location - MidPoint) + MidPoint).astype(int) for Location in Shape]
    return RotatedShape

###
#Generates the grid coordinates of a Shape, where the location of the Shape
#is determined by rotationlabel Shapeconfiguration[0] and translation
#Shapeconfiguration[1], with respect to a starting position of the shape. 
###
def GenerateShapeLocation(ShapeConfiguration,Shape, CubeRotations):
    Rotation = CubeRotations[ShapeConfiguration[1]]
    Translation = ShapeConfiguration[0]
    RotatedShape = [np.matmul(Rotation,Location) for Location in Shape]
    TranslatedShape = [np.rint(np.add(Translation,Location)).astype(int) for Location in RotatedShape]
    return TranslatedShape

###
#Checks whether all grid coordinates of a Shape are all contained in the 5x5x5
#grid. 
###
def GoodShapeLocation(ShapeLocation):
    for Location in ShapeLocation:
        if np.any(Location > 4.5):
            return 0 
        if np.any(Location < -0.5):
            return 0 
    return 1

###
#This function adds a shape to the cube. It also computes the 
#Energy difference generated by adding this shape
###
def AddShapeToCube(Cube,ShapeLocation):
    for Location in ShapeLocation:
        Value = Cube[tuple(Location)]
        Cube[tuple(Location)] = Value + 1
    return Cube

"""
This function checks whether Shapes in the cube overlap
"""
def CheckCubeConsistency(Cube, Locations):
    for Location in Locations:
        if not Cube[tuple(Location)] == 0 or Cube[tuple(Location)] == 1:
            return 0
    return 1
"""
This function removes a shape from the cube. It prints an error if 
there is no shape in this location. However, it would be better to check if
there is a shape at this location before doing any
"""
def RemoveShapeFromCube(Cube,ShapeLocation):
    EnergyDifference = 0
    for Location in ShapeLocation:
        Value = Cube[tuple(Location)]
        if Value == 0: print('error RemoveShape, Catastrophic')
        if not Value == 1:
            EnergyDifference += 3 - 2*Value
        Cube[tuple(Location)] = Cube[tuple(Location)] - 1
    return EnergyDifference


#Calculate the energy of a specific cube
def EnergyFunction(Cube):
    Energy = 0
    for index, value in np.ndenumerate(Cube):
        if not value == 0:
            Energy = Energy + (value - 1)**2
    return(Energy)
            
#This function tries all possible configurations for a block. If the
#Block fits, it tries a new block. If it finishes the puzzle, it returns 1, 
#If it does not finish the puzzle, a nnew configuration is tried out

#This function modifies the ShapeLocations and Cube
# by replacing it with a neighbour.
#It then reports the Energy Difference, and tells how it has changed the Cube 
#After applying this function, this allows the change to be reverted
#This function can calculate the energy difference faster than
#The energy function
def Neighbour(ShapeLocations,Cube,Rotations):
    #For now, we only allow translations
    ShapeRemovedIndex  = random.choice(range(len(ShapeLocations)))
    ShapeRemoved = ShapeLocations[ShapeRemovedIndex]
    #print(ShapeRemoved)
    EnergyDifference = 0
    DecisionParameter = random.random()
    if DecisionParameter > 0.5: #Translate
        NewShapeLocation = []
        Translation = np.array(random.choice(
            [[0,0,1],[1,0,0],[0,1,0],[0,0,-1],[-1,0,0],[0,-1,0]]))
        for Location in ShapeRemoved:
            NewShapeLocation.append(Translation + Location)
           
    else: #Rotate
        RandomRotation = random.choice(Rotations)
        NewShapeLocation = RotateShape(ShapeRemoved,RandomRotation)
    if GoodShapeLocation(NewShapeLocation):
        EnergyDifference += AddShapeToCube(Cube,NewShapeLocation)
        EnergyDifference += RemoveShapeFromCube(Cube,ShapeRemoved)
        return EnergyDifference,NewShapeLocation,ShapeRemoved, ShapeRemovedIndex
    return 0,[],[],0


def GenerateBaseShapes():
    ShapeL = [np.array([i,j,0]) for i in range(4) for j in range(2)]
    for j in range(2):
        ShapeL.append(np.array([3,j,1]))
    ShapeY = [np.array([i,j,0]) for i in range(4) for j in range(2)]
    for j in range(2):
        ShapeY.append(np.array([2,j,1]))
    return ShapeL,ShapeY

def GenerateCube(CubeSize):    
    Cube = np.zeros((CubeSize,CubeSize,CubeSize))
    Locations = [np.array([i,j,k]) for i in range(CubeSize) 
                     for j in range(CubeSize) for k in range(CubeSize)]
    return Cube,Locations



def GenerateAllowedShapeLocations(Shape, ShapeConfigurations, CubeRotations):
    PossibleShapeLocations = [GenerateShapeLocation(ShapeConfiguration, Shape, CubeRotations)
                       for ShapeConfiguration in ShapeConfigurations]
    ProperShapeLocations = [ShapeLocation for ShapeLocation in PossibleShapeLocations
                             if GoodShapeLocation(ShapeLocation)]
    ProperShapeConfigurations = [ShapeConfiguration
                       for ShapeConfiguration in ShapeConfigurations
                       if GoodShapeLocation(
                               GenerateShapeLocation(ShapeConfiguration, Shape, CubeRotations))]
    return ProperShapeLocations, ProperShapeConfigurations

def Overlap(Shape1,Shape2, CubeSize):
    Cube = np.zeros((CubeSize,CubeSize,CubeSize))
    AddShapeToCube(Cube, Shape1)
    AddShapeToCube(Cube, Shape2)
    if np.any(Cube > 1):
        return 1
    return 0
    
def NumberOfCombinations():
    NCR = 1
    for i in range(6):
        NCR = NCR *(768 - i)/(i+1)
        NCR = NCR**2
    return NCR

def GenerateGraphEV():
    
    CubeSize = 5
    ShapeL,ShapeY = GenerateBaseShapes()
    Cube,Locations = GenerateCube(CubeSize)
    
    RotationLabels = [i for i in range(24)]
    ShapeConfigurations = [[Location,RotationLabel] for Location in Locations
                     for RotationLabel in RotationLabels]
    
    CubeRotations = GenerateCubeRotations()
    
    ShapeLs, ShapeLConfigurations = GenerateAllowedShapeLocations(ShapeL, ShapeConfigurations, CubeRotations)
    ShapeYs, ShapeYConfigurations = GenerateAllowedShapeLocations(ShapeY, ShapeConfigurations, CubeRotations)
    
    Shapes = ShapeYs + ShapeLs
    

    E = []
    for i in range(len(Shapes)):
        for j in range(i):
            if Overlap(Shapes[i],Shapes[j], CubeSize):
                E.append((i,j))
    V = list(range(len(Shapes)))
    with open('saved_edges.pkl', 'wb') as f:
        pickle.dump(E, f)
    with open('saved_vertices.pkl', 'wb') as f:
        pickle.dump(V, f)
    with open('saved_shapes.pkl', 'wb') as f:
        pickle.dump(Shapes, f)   

#Constructs graph dictionary from lists E,V with V immutable entries
def GenerateNeighbourDictionary(E,V):
    NeighbourDict = {}
    for i in V:
        NeighbourDict[i] = []
    for i,j in E:
        NeighbourDict[i] = NeighbourDict[i] + [j]
        NeighbourDict[j] = NeighbourDict[j] + [i]
    with open('NeighbourDict.pkl', 'wb') as f:
        pickle.dump(NeighbourDict,f)
    return NeighbourDict

def GenerateGraphArray(E,V):
    GraphArray = np.zeros((len(V),len(V)))
    for i,j in E:
        GraphArray[i,j] = 1
        GraphArray[j,i] = 1
    np.fill_diagonal(GraphArray,1)
    with open('GraphArray.pkl', 'wb') as f:
        pickle.dump(GraphArray,f)
    return GraphArray

def InitializeAges(V):
    AgeDict = {}
    for Vertex in V:
        AgeDict[Vertex] = 0
    return AgeDict

def InitializeEdgeWeights(E):
    EdgeWeightsDict = {}
    for edge in E:
        EdgeWeightsDict[edge] = 1
    return EdgeWeightsDict

def InitializeDScores(V):
    DScores = {}
    for Vertex in V:
        DScores[Vertex] = 0
    return DScores

def InitializeConfChange(V):
    ConfChangeDict = {}
    for Vertex in V:
        ConfChangeDict[Vertex] = bool(1)
    return ConfChangeDict

def ConstructC():
    C = []
    return C

def FindUnCoveredEdges(E,C):
    UnCoveredEdges = [] 
    return UnCoveredEdges

#Sort S according to dscore from low to high. The elements with the maximum
#dscore Should be sorted according to age. 
def SortD(C, DScoresDict, Reverse):
    DScores = []
    for Vertex in C:
        DScores.append(DScoresDict[Vertex])
    CNew = [Vertex for (DScore,Vertex) in sorted(zip(DScores,C), key=lambda pair: pair[0], reverse = Reverse)]
    return CNew

#Updates the UnCoveredEdges set After Adding (Added = 1) or removing (Added = 0)
#A vertex
def UpdateUnCoveredEdges(UnCoveredEdges, Vertex, Added, C ,V, NeighbourDict):
    if Added:
        NewUncoveredEdges = []
        for Edge in UnCoveredEdges:
            if not Vertex in Edge:
                NewUncoveredEdges.append(Edge)
        return NewUncoveredEdges
                
    else: 
        for Vertex2 in NeighbourDict[Vertex]:
            if Vertex2 not in C: #Takes Quite Long, improved by CComp
                assert not Vertex == Vertex2
                Edge = tuple(sorted((Vertex,Vertex2), reverse = True))
                assert isinstance(Edge,tuple)
                assert not Edge in UnCoveredEdges 
#                print(Edge)
                UnCoveredEdges.append(Edge)
    return UnCoveredEdges

def UpdateEdgeWeightsDict(EdgeWeightsDict, UnCoveredEdges):
    return 0

def UpdateDScore():
    return 0


sorted((2,1))
#Insert a vertex so that the list remains ordered
def InsertVertexToC(Vertex,C, DscoresDict, Ages):
    return C

#Calculate the Average Outcome of a Dictionary
def CalcAverage(Dictionary):
    Average = 0
    return Average

def NuMVC(E, V, NeighbourDict, GraphArray, CutOffTime, WeightLimit, WeightLossRate):
    EdgeWeightsDict = InitializeEdgeWeights(E)
    DScoresDict = InitializeDScores(V)
    ConfChangeDict = InitializeConfChange(V)
    AgeDict = InitializeAges(V)
    C = copy.deepcopy(V) #If DScoresDict is not uniform, V needs to be sorted
    CComp = []
    #Alternatively
    #C = ConstructC()
    #CompC = [Vertex for Vertex in V if not Vertex in C] #O(VC)
    
    Cover = C
    UnCoveredEdges = []
    CounterStart = 0
    CounterEnd = 0
    CoverCounter = 0
    
    InitialTime = time.time()
    while time.time() - InitialTime < CutOffTime:
        CounterStart += 1
        """
        for Edge in E:
            assert isinstance(EdgeWeightsDict[Edge], int)
            assert isinstance(Edge,tuple)
            assert len(Edge) == 2
        for Vertex in V:
            assert isinstance(DScoresDict[Vertex], int) 
            assert isinstance(ConfChangeDict[Vertex], bool) 
            assert isinstance(AgeDict[Vertex], int)  
            assert isinstance(Vertex, int)
        """
        if not UnCoveredEdges:
            if not C:
                print(time.time() - InitialTime)
                break
            Cover = C
            Vertex = C.pop(-1)
            print(Vertex)
            UpdateUnCoveredEdges(UnCoveredEdges, Vertex,0,C,V,NeighbourDict)
            UpdateEdgeWeightsDict() #ToWrite
            UpdateDScore()
            CoverCounter += 1
            continue
        Vertex = C.pop(-1)
        ConfChangeDict[Vertex] = bool(0)
        for Neighbour in NeighbourDict[Vertex]:
            ConfChangeDict[Neighbour] = bool(1)
        
        print('before',len(UnCoveredEdges))
        UpdateUnCoveredEdges(UnCoveredEdges,Vertex,0,C,V, NeighbourDict)
        UpdateEdgeWeightsDict() #ToWrite
        UpdateDScore()
        Edge = random.choice(UnCoveredEdges)
        ReducedEdge = ()
        for Vertex in Edge:
            if ConfChangeDict[Vertex]:
                ReducedEdge = ReducedEdge + (Vertex,)
#        ReducedEdge = (Vertex for Vertex in Edge if ConfChangeDict[Vertex])
        SortD(ReducedEdge, DScoresDict, Reverse = True)
        Vertex = ReducedEdge[0]
        InsertVertexToC(Vertex,C, DScoresDict, AgeDict)
        for Neighbour in NeighbourDict[Vertex]:
            ConfChangeDict[Neighbour] = bool(1)        
        print('Mid',len(UnCoveredEdges))
        UpdateUnCoveredEdges(UnCoveredEdges,Vertex,1,C,V, NeighbourDict)
        UpdateEdgeWeightsDict() #ToWrite
        UpdateDScore()
        for Edge in UnCoveredEdges:
            assert isinstance(Edge, tuple)
            EdgeWeightsDict[Edge] = EdgeWeightsDict[Edge] + 1
        W = CalcAverage(EdgeWeightsDict)
        if W > WeightLimit:
            for Edge in E:
                EdgeWeightsDict[Edge] = math.ceil(EdgeWeightsDict[Edge]*WeightLossRate)
        CounterEnd += 1
        print('End',len(UnCoveredEdges))
    print('CounterStart', CounterStart, '\n', 'CounterEnd', CounterEnd, '\n CoverCounter', CoverCounter)
    return Cover,C,UnCoveredEdges
        


    

    
    #In this code, we build two global objects. The ConfigurationTracker tracks
    #the configurations used to build blocks. The Cube tracks which locations
    #contain blocks. We try to add blocks until all blocks are contained in the
    #Cube. Then the functions and loops should end. 
    """
    (G,cutoff)
    Input: graph G = (V,E), the cutoff time
    Output: vertex cover of G
    2 begin
    3 initialize edge weights and dscores of vertices;
    4 initialize the confChange array as an all-1 array;
    5 construct C greedily until it is a vertex cover;
    6 C∗ := C;
    7 while elapsed time < cutoff do
    8   if there is no uncovered edge then
    9   C∗ := C;
    10  remove a vertex with the highest dscore from C;
    11  continue;
    12 choose a vertex u ∈ C with the highest dscore, breaking ties in favor of the oldest
    one;
    13 C := C\{u}, confChange(u) := 0 and confChange(z) := 1 for each z ∈ N(u);
    14 choose an uncovered edge e randomly;
    15 choose a vertex v ∈ e such that confChange(v) = 1 with higher dscore, breaking ties
    in favor of the older one;
    16 C := C ∪ {v}, confChange(z) := 1 for each z ∈ N(v);
    17 w(e) := w(e) + 1 for each uncovered edge e;
    18 if w ≥ γ then w(e) := ⌊ρ · w(e)⌋ for each edge e;
    19 return C∗;
    20 end
    """
    
def main():
    WeightLimit = 100
    WeightLossRate = 0.5
    CutOffTime = 0.05
    
    
    with open('saved_edges.pkl', 'rb') as f:
        E = pickle.load(f)
    with open('saved_vertices.pkl', 'rb') as f:
        V = pickle.load(f)
    with open('NeighbourDict.pkl', 'rb') as f:
        NeighbourDict = pickle.load(f)
    with open('GraphArray.pkl', 'rb') as f:
        GraphArray = pickle.load(f)
        
    #duration of algorithm in seconds
    Cover,C,UnCoveredEdges = NuMVC(E, V, NeighbourDict, GraphArray, CutOffTime, WeightLimit, WeightLossRate)
    CComp = [Vertex for Vertex in V if not Vertex in C]
    print(CComp)
    print(C==V)
    print(len(UnCoveredEdges))
if __name__ == "__main__":
    main()

              
              